@use "sass:list";
@use "sass:map";
@use "sass:meta";
@use "sass:math";

// Susy Settings
// =============

// Susy Language Defaults
// ----------------------
// - PRIVATE

@include susy-defaults((
  container: auto,
  math: fluid,
  output: float,
  container-position: center,
  gutter-position: after,
  global-box-sizing: content-box,
  debug: (
    image: hide,
    color: rgba(#66f, .25),
    output: background,
    toggle: top right,
  ),
));


// Valid Keyword Values
// --------------------
// - PRIVATE: DONT'T TOUCH
$susy-keywords: (
  container: auto,
  math: static fluid,
  output: isolate float,
  container-position: left center right,
  flow: ltr rtl,
  gutter-position: before after split inside inside-static,
  box-sizing: border-box content-box,
  span: full,
  edge: first alpha last omega full,
  spread: narrow wide wider,
  gutter-override: no-gutters no-gutter,
  role: nest,
  clear: break nobreak,
  debug image: show hide show-columns show-baseline,
  debug output: background overlay,
);


// Parse Susy Keywords and Maps
// ----------------------------
@function parse-settings(
  $short: $susy
) {
  $_return: ();

  @if meta.type-of($short) == map {
    $_return: $short;
  } @else {
    @each $item in $short {
      // strings
      @if meta.type-of($item) == string {
        @each $key, $value in $susy-keywords {
          @if list.index($value, $item) {
            $_key-value: list.append($key, $item);
            $_return: _susy-deep-set($_return, $_key-value...);
          }
        }
      // maps
      } @else if meta.type-of($item) == map {
        $_return: map.merge($_return, $item);
      }
    }
  }

  @return $_return;
}


// Parse Columns & Gutters
// -----------------------
@function parse-layout(
  $short
) {
  $_return: ();
  $_columns: ();
  $_gutters: null;

  @if not(math.is-unitless(list.nth(list.nth($short, 1), 1))) {
    $_gutters: list.nth($short, 1);
  } @else {
    $_columns: (columns: list.nth($short, 1));
    $_gutters: if(list.length($short) > 1, list.nth($short, 2), $_gutters);
  }

  @if meta.type-of($_gutters) == list and list.length($_gutters) > 0 {
    $_gutters: (
      gutters: math.div(list.nth($_gutters, 2), list.nth($_gutters, 1)),
      column-width: list.nth($_gutters, 1),
    );
  } @else {
    $_gutters: if($_gutters, (gutters: $_gutters), ());
  }

  $_return: map.merge($_return, $_columns);
  $_return: map.merge($_return, $_gutters);

  @return $_return;
}


// Parse Grid/Context
// ------------------
@function parse-grid(
  $short: $susy
) {
  $_return: parse-settings($short);
  $_layout: ();

  @if meta.type-of($short) == map {
    $_return: $short;
  } @else {
    @each $item in $short {
      // number or list
      @if meta.type-of($item) == number or meta.type-of($item) == list {
        @if meta.type-of($item) == list or math.is-unitless($item) {
          $_layout: list.append($_layout, $item);
        } @else {
          $_return: map.merge($_return, (container: $item));
        }
      }
    }

    $_layout: if(list.length($_layout) > 0, parse-layout($_layout), $_layout);
  }

  @return map.merge($_return, $_layout);
}


// Parse Span
// ----------
@function parse-span(
  $short,
  $key: span
) {
  $_return: ();

  @if meta.type-of($short) == map {
    $_return: $short;
  } @else {
    $_at: list.index($short, at);

    @if $_at {
      $_loci: $_at + 1;
      $_location: list.nth($short, $_loci);
      $_return: map.merge($_return, (location: $_location));
      $short: list.set-nth($short, $_at, null);
      $short: list.set-nth($short, $_loci, null);
    }

    $_i: 1;
    $_span: ();

    @while $_i <= list.length($short) {
      $_this: math.div($short, $_i);

      @if meta.type-of($_this) == number {
        $_span: list.append($_span, $_this);
        $short: list.set-nth($short, $_i, null);
      } @else if $_this == of {
        $short: list.set-nth($short, $_i, null);
        $_i: list.length($short) + 1;
      }

      $_i: $_i + 1;
    }

    @if list.length($_span) > 0 {
      $_span: if(list.length($_span) == 1, list.nth($_span, 1), $_span);
      $_return: map.merge($_return, ($key: $_span));
    }

    $_return: map.merge($_return, parse-grid($short));
  }

  @return $_return;
}


// Parse Gutters
// -------------
@function parse-gutters(
  $short: $susy
) {
  $_gutters: parse-span($short, gutter-override);
  $_span: susy-get(gutter-override, $_gutters);

  @if $_span and not(map.get($_gutters, columns)) {
    $_context: ();
    $_new: ();

    @each $item in $_span {
      @if meta.type-of($item) == number and math.is-unitless($item) {
        $_context: list.append($_context, $item);
      } @else {
        $_new: list.append($_new, $item);
      }
    }

    $_context: parse-grid($_context);
    $_new: if(list.length($_new) == 0, null, $_new);
    $_new: if(list.length($_new) == 1, list.nth($_new, 1), $_new);
    $_new: (gutter-override: if($_new != $_span, $_new, $_span));

    $_gutters: map.merge($_gutters, $_new);
    $_gutters: map.merge($_gutters, $_context);
  }

  @return $_gutters;
}
